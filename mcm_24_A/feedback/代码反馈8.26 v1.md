# 第一问代码问题反馈

## 问题1：位置递推求解的策略有误

### 建模方案

在建模方案中，我们认为板凳是**刚体**，这点非常重要，这直接决定了我们对于把手位置的求解不是简单的在弧线上减去板凳长度得到下一个把手的位置，而是必须在两个约束下求解：
- 相邻把手之间的欧氏距离恒定为1
- 把手永远位于螺线上

回到咱们得建模方案里面，就是：

> ##### 核心物理约束
>任意时刻 $t$，第 $i$ 个把手 $P_i$ 的坐标 $(x_i, y_i)$ 与其前一个把手 $P_{i-1}$ 的坐标 $(x_{i-1}, y_{i-1})$ 之间的欧几里得距离（直线距离）恒等于板凳的有效长度 $L_i$。其数学表达式为：
$$
\sqrt{(x_i(t) - x_{i-1}(t))^2 + (y_i(t) - y_{i-1}(t))^2} = L_i
$$
>##### 位置递推方程
>我们将螺线的参数方程代入上述约束条件，并对等式两侧同时平方。在求解t时刻第 $i$ 个把手的位置时，$(x_{i-1}(t), y_{i-1}(t))$ 是已知的，而未知的只有角度 $\theta_i(t)$。因此，我们需要求解的通用递推方程是：
$$
\left(b\theta_i(t)\cos(\theta_i(t)) - x_{i-1}(t)\right)^2 + \left(b\theta_i(t)\sin(\theta_i(t)) - y_{i-1}(t)\right)^2 = L_i^2
$$
其中：
>- $L_1 = 2.86 \text{ m}$
>- $L_i = 1.65 \text{ m}$ (对于 $i \geq 2$)

这也是为什么在建模方案中需要采用牛顿迭代法来求解而不是直接根据龙头位置向后递推的关键原因

### 编程实现

现在我们回到第一版编程实现中，存在的问题主要是在`solver.py`中

    # 预先计算每个把手到龙头前把手的弧长距离 (沿中心线顺序), 用于快速定位theta
    # handle 0 = head front
    # handle i 与 handle i-1 之间距离为 distance_between_handles(i-1)
    intervals = [cp.distance_between_handles(i) for i in range(cp.n_total)]  # len n_total
    cum_handle_s_offsets = [0.0]
    acc = 0.0
    for d in intervals:
        acc += d
        cum_handle_s_offsets.append(acc)
    # 长度 = n_total+1 = handle_count

这一步是直接将板凳长度看作是沿着弧线的长度了，因此直接用递减的方法来求出初始状态下的所有把手位置，**这是不对的！**

同理`solver.py`代码中的这一部分也是同样的问题

    # 先求所有时刻龙头theta (用弧长倒推) s = s0 + v*t
    for ti, t in enumerate(times):
        # 1. 龙头
        s_head = s_head_0 - v_head * t
        guess = theta[ti-1, 0] if ti > 0 else theta_head_0
        theta_head = spiral_arc_length_inv(s_head, guess)
        theta[ti, 0] = theta_head
        x_head, y_head = spiral_pos(theta_head)
        x[ti, 0], y[ti, 0] = x_head, y_head
        speed[ti, 0] = v_head
        tx0, ty0 = spiral_tangent_unit(theta_head)
        vx[ti, 0] = v_head * tx0
        vy[ti, 0] = v_head * ty0

        # 2. 其他把手位置
        for hi in range(1, n_handles):
            s_i = s_head - cum_handle_s_offsets[hi]
            if s_i <= 0:
                theta_i = 0.0
            else:
                guess_i = theta[ti, hi-1]
                theta_i = spiral_arc_length_inv(s_i, guess_i)
            theta[ti, hi] = theta_i
            xi, yi = spiral_pos(theta_i)
            x[ti, hi], y[ti, hi] = xi, yi




# 第二问代码反馈

目前看来由于沿用了第一问的错误位置递推算法，导致第二问的结果也是存在问题的。

但同时这里计算出来的结果是在初始情况下就出现了碰撞，这里是我初步方案的问题，应该搜索的范围是

$$[\theta-3\pi,\theta-\pi]$$

而不是$[\theta-3\pi,\theta]$，因为如果是后者的话会导致也检测到相邻的板凳，因此在`Problem 2/collision.py`中需要更改一下这段代码：

    # 选择可能碰撞对 (索引基于rects顺序 i=0..n_benches-1)

    def candidate_pairs(theta_list: List[float]) -> List[Tuple[int, int]]:
        # 策略: 只检查 i 与 j (j>i) 如果 theta_j 在 [theta_i - 3*pi, theta_i) 范围内
        res = []
        for i in range(len(theta_list)):
            ti = theta_list[i]
            low = ti - 3 * math.pi
            for j in range(i + 1, len(theta_list)):
                tj = theta_list[j]
                if low <= tj <= ti:
                    res.append((i, j))
        return res

将`if low<=tj<=ti:`改为`if low<=tj<=ti-math.pi`

**同时在Problem2的solver2.py中对于300s后的时间预测并没有采用复用第一问计算方法的方式，而是使用线性插值插值到400s，对于这个做法我认为存在几个问题：1. 本身板凳龙的运动过程就是非线性的，使用线性插值的精度不高； 2. 400s的上限过低，很有可能到了400s还是没有碰撞**


# 第三问代码反馈

首先还是由于位置递推公式的问题，导致后面的结果都是有问题的，需要更改；

其次是这里我看了一下，用的是二分搜索？看起来感觉没有网格搜索那么直观，但是如果结果最后没问题的话也行。


## 最后强调一个，就是所有的计算尽量使用numba进行加速，我看到虽然都导入了numba包，但是都没有使用，虽然在这道计算量比较小的题目上看起来没什么必要，但是遇到计算量较大的题目的话就非常需要了，比如23年A题
